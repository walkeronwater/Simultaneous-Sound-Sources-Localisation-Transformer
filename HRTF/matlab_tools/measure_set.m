function [elev_v,azim_v,lsp_elev_v] = measure_set(keyword_s,elev_subset_v);

% MEASURE_SET Returns azimuths and elevations of a given measurement set
%
% Usage
%   [elev_v,azim_v,lsp_elev_v] = measure_set(keyword_s,elev_subset_v);
%
% Input
%   keyword_s     : the measurement set name (string)
%   elev_subset_v : a subset of elevations (optioanal)
%
% Output
%   elev_v     : a vector of elevations (with as many copies as the number of azimuths per elevation)
%   azim_v     : a vector of azimuths
%   lsp_elev_v : vector of loudspeaker elevations
%
% Measurement set types :
%   'Human15' for a 15 degrees increment in azimuth,
%   'KemarComplete' for a complete azimuth distribution according to the KEMAR measurements,
%   'Kemar15' for a partial distribution, close to the 'Human15' one.
%   'Spat' almost KEMAR measurements, excepted at 80 degrees elevation
%   'Listen' 15 by 15 degrees measurement grid (Listen project)
%
% See also DATA_FORMATS, LOAD_IMPULSE_RESPONSES
%
% Authors
%   Larcher Veronique (was AZSET)
%   Rio Emmanuel
%   (c) Ircam - June 2001

% Todo check for Human15 in measurements
% Todo allow different structures as argument (respecting the format)

human_15_S.elev_v = [-10:10:40 90]';
human_15_S.azim_C = { ...
        [0:15:345]', ...
        [0:15:345]', ...
        [0:15:345]', ...
        [0:15:345]', ...
        [0:15:345]', ...
        [0:15:345]', ...
        [0]...
    };
kemar_complete_S.elev_v = [-40:10:90]';
kemar_complete_S.azim_C = { ...
        round([0:55]'*360/56), ...
        [0:6:354]', ...
        [0:5:355]', ...
        [0:5:355]', ...
        [0:5:355]', ...
        [0:5:355]', ...
        [0:5:355]', ...
        [0:6:354]', ...
        round([0:55]'*360/56), ...
        [0:8:352]', ...
        [0:10:350]', ...
        [0:15:345]', ...
        [0:15:345]', ...
        [0]...
    };
kemar_15_S.elev_v = [-10:10:40 90]';
kemar_15_S.azim_C = { ...
        [0:15:345]', ...
        [0:15:345]', ...
        [0:15:345]', ...
        [0:15:345]', ...
        [0 12 30 42 60 72 90 102 120 132 150 162 180 192 210 222 240 252 270 282 300 312 330 342]', ...
        [0 13 26 45 58 77 90 103 122 135 148 167 180 193 212 225 238 257 270 283 302 315 328 347]', ...
        [0]...
    };
spat_S.elev_v = [-40:10:90]';
spat_S.azim_C = { ...
        round([0:55]'*360/56), ...
        [0:6:354]', ...
        [0:5:355]', ...
        [0:5:355]', ...
        [0:5:355]', ...
        [0:5:355]', ...
        [0:5:355]', ...
        [0:6:354]', ...
        round([0:55]'*360/56), ...
        [0:8:352]', ...
        [0:10:350]', ...
        [0:15:345]', ...
        [0:30:345]', ...
        [0]...
    };
listen_S.elev_v = [-45:15:90]';
listen_S.azim_C = { ...
      [0:15:345]', ...
      [0:15:345]', ...
      [0:15:345]', ...
      [0:15:345]', ...
      [0:15:345]', ...
      [0:15:345]', ...
      [0:15:345]', ...
      [0:30:330]', ...
      [0:60:300]', ...
      [0] ...
      };

azim_v = [];
elev_v = [];
lsp_elev_v = [];
switch keyword_s
case 'Human15'
  measurement_set_S = human_15_S;
case 'KemarComplete'
  measurement_set_S = kemar_complete_S;
case 'Kemar15'
  measurement_set_S = kemar_15_S;
case 'Spat'
  measurement_set_S = spat_S;
case 'Listen'
  measurement_set_S = listen_S;
otherwise
  disp(['MEASURE_SET : bad measurement set ' keyword_s]);
  return;
end

% if a subset of elevations is not given, outputs the whole set
if ~exist('elev_subset_v');
  elev_subset_v = measurement_set_S.elev_v;
end
% goes through elevations
elevation_n = min(elev_subset_v);
while ~isempty(elevation_n)
    % finds azimuths for this elevation
    index_n = find(measurement_set_S.elev_v==elevation_n);
    if ~isempty(index_n)
        additional_azim_v = measurement_set_S.azim_C{index_n};
        % concatenates output azimuth and elevation vectors
        azim_v = [azim_v; additional_azim_v];
        elev_v = [elev_v; elevation_n*ones(size(additional_azim_v))];
        lsp_elev_v = [lsp_elev_v; elevation_n];
   else
        disp(sprintf('MEASURE_SET : bad elevation %i',elevation_n));
    end
    % goes to next elevation
    elevation_n = min(elev_subset_v(find(elev_subset_v>elevation_n)));
end

